#!/usr/bin/env python3
# Tile multiple monitors side-by-side
import socket
import subprocess
import time


def get_monitors():
    lines = subprocess.check_output(['xrandr']).decode('utf8').splitlines()
    return [line.split()[0] for line in lines if ' connected' in line]


if __name__ == '__main__':
    time.sleep(1)
    monitors = get_monitors()
    hostname = socket.gethostname()

    # tile monitors side-by-side, based on physical ports
    #
    # For example, with the below grahpics card, excluing DVI port
    # Left most monitor should go to the left most port (DP 1) and so on
    #
    # +------------------------------------------------+
    # |   +----------------+    | +------------------+ |
    # |   |    D V I       |    | |  |  Exhaust   |  | |
    # |   +----------------+    | +------------------+ |
    # +------------------------------------------------+
    # |   +-------+ +--------+  +-------+   +-------+  |
    # |   +  DP 1 | |  HDMI  |  +  DP 2 |   +  DP 3 |  |
    # |    \------+ \-------/    \------+    \------+  |
    # +------------------------------------------------+

    is_daisy_chaining = any(monitor.endswith('.8') for monitor in monitors)
    if is_daisy_chaining:
        sorted_monitors = list(sorted(monitors, reverse=True))
    else:
        sorted_monitors = list(sorted(monitors))

    prev = None
    for monitor in sorted_monitors:
        if prev:
            subprocess.check_call(['xrandr', '--output', monitor, '--right-of', prev])
        prev = monitor

    if is_daisy_chaining:
        # Disable power saving, this is necessary for some reason
        subprocess.check_call(['xset', 'dpms', 'force', 'off'])
        subprocess.check_call(['xset', 'dpms', 'force', 'on'])
